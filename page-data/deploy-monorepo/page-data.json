{"componentChunkName":"component---src-templates-blog-post-js","path":"/deploy-monorepo/","webpackCompilationHash":"c3c092764e3028f78add","result":{"data":{"site":{"siteMetadata":{"title":"My Notes","author":"Yasser Zadeh"}},"markdownRemark":{"id":"bfd77769-7245-5dad-8a93-9388650ba301","excerpt":"The problem is how to deploy a monorepo that is managed by Lerna. In monorepo, we have many repositories, which some of them are services to be deployed…","html":"<p>The problem is how to deploy a monorepo that is managed by <a href=\"https://github.com/lerna/lerna\">Lerna</a>. In monorepo, we have many repositories, which some of them are services to be deployed standalone, and some are dependencies. On each commit or pull-request, it is possible to touch one or more repositories.</p>\n<p>Here is one possible way using Gitlab web hooks, Jenkins, and Docker. The sample code can be found here <a href=\"https://github.com/yassermzh/deploy-monorepo\">yassermzh/deploy-monorepo</a>.</p>\n<p>As you push to Gitlab, it triggers a Jenkins job. For this, just need to use Gitlab web hooks and basic Jenkins settings.</p>\n<p>This job, which is a pipleline one, checkouts the repository, and loads the <code class=\"language-text\">tasks</code> package Jenkinsfile at: <code class=\"language-text\">packages/tasks/Jenkinsfile</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"groovy\"><pre class=\"language-groovy\"><code class=\"language-groovy\">node <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">def</span> ctx <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span>\n\n  <span class=\"token function\">stage</span><span class=\"token punctuation\">(</span><span class=\"token string\">'checkout'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">def</span> scmVars <span class=\"token operator\">=</span> <span class=\"token function\">checkout</span><span class=\"token punctuation\">(</span>scm<span class=\"token punctuation\">)</span>\n    ctx<span class=\"token operator\">.</span>GIT_COMMIT <span class=\"token operator\">=</span> scmVars<span class=\"token operator\">.</span>GIT_COMMIT\n    ctx<span class=\"token operator\">.</span>GIT_PREV_COMMIT <span class=\"token operator\">=</span> scmVars<span class=\"token operator\">.</span>GIT_PREVIOUS_COMMIT\n    ctx<span class=\"token operator\">.</span>COMMIT_MSG <span class=\"token operator\">=</span> <span class=\"token function\">lastCommitMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">def</span> packages <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">'notify'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">]</span>\n\n  <span class=\"token function\">checkPackages</span><span class=\"token punctuation\">(</span>packages<span class=\"token punctuation\">,</span> ctx<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>There we list all packages that should be deployed as services. Mostly the packages are not services and used as dependencies. It adds the last commit along with the previous commit that was deployed successfully. Then it’s possible to check whether there are any changes in each of packages within these those commits.</p>\n<div class=\"gatsby-highlight\" data-language=\"groovy\"><pre class=\"language-groovy\"><code class=\"language-groovy\"><span class=\"token keyword\">def</span> <span class=\"token function\">checkPackage</span><span class=\"token punctuation\">(</span>pkg<span class=\"token punctuation\">,</span> ctx<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token function\">isChanged</span><span class=\"token punctuation\">(</span><span class=\"token string gstring\">\"packages/<span class=\"token expression\"><span class=\"token punctuation\">$</span><span class=\"token punctuation\">{</span>pkg<span class=\"token punctuation\">}</span></span>/\"</span><span class=\"token punctuation\">,</span> ctx<span class=\"token operator\">.</span>GIT_COMMIT<span class=\"token punctuation\">,</span> ctx<span class=\"token operator\">.</span>GIT_PREV_COMMIT<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span>\n    ctx<span class=\"token operator\">.</span>COMMIT_MSG<span class=\"token operator\">.</span><span class=\"token function\">endsWith</span><span class=\"token punctuation\">(</span><span class=\"token string gstring\">\"deploy <span class=\"token expression\"><span class=\"token punctuation\">$</span><span class=\"token punctuation\">{</span>pkg<span class=\"token punctuation\">}</span></span>\"</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span>\n    ctx<span class=\"token operator\">.</span>COMMIT_MSG<span class=\"token operator\">.</span><span class=\"token function\">contains</span><span class=\"token punctuation\">(</span><span class=\"token string gstring\">\"deploy all\"</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>To check whether to deploy a package, it also considers commit message to enable deploying a package or all packages without having any changes. This way we make sure it’s possible to override the detect change rule. So to forcefully deploy PACKAGE1, we just need an empty commit with message <code class=\"language-text\">deploy PACKAGE1</code> like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> commit -m <span class=\"token string\">\"deploy PACKAGE1\"</span> --allow-empty</code></pre></div>\n<p>Each deployable package has one Jenkinsfile at <code class=\"language-text\">packages/PACKAGE/scripts/Jenkinsfile</code> that knows how to deploy itself. So we only load Jenkisnfile of those packages, and deploy one by one sequentially.</p>\n<p>The structure of the monorepo is as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  |\n  |-- packages/\n  |           /tasks/Jenkinsfile\n  |           /notify/\n  |                  /scripts/Jenkinsfile\n  |           /email/</code></pre></div>\n<p>in which the <code class=\"language-text\">notify</code> package is a service, and <code class=\"language-text\">email</code> package is a dependency for <code class=\"language-text\">notify</code>.</p>\n<h2>Development flow</h2>\n<p>To run locally, since it’s managed by Lerna, we just go with basic Lerna usage:</p>\n<ul>\n<li>\n<p>To install dependencies</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">lerna bootstrap --hoist</code></pre></div>\n</li>\n<li>\n<p>To add dependencies\nHere adding <code class=\"language-text\">@company/email</code> to <code class=\"language-text\">@company/notify</code>. As you notice, we use <code class=\"language-text\">@company</code> to scope npm packages.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">lerna <span class=\"token function\">add</span> @company/email --scope @company/notify</code></pre></div>\n</li>\n<li>\n<p>To run only one package</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">cd</span> packages/notify\n<span class=\"token function\">npm</span> start</code></pre></div>\n</li>\n<li>\n<p>To run all packages</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">lerna run start</code></pre></div>\n</li>\n</ul>\n<p>And to deploy on the staging server, we just publish it to the local NPM registry. During the publishing process, it would ask to bump the changed packages’ version, publishes them to the registry, and push the changes to Gitlab that would trigger the Jenkins jobs and deploy the changed services.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">lerna publish --registry http://registry.company.com</code></pre></div>\n<p>I managed to deploy each branch to it’s own space by extending this setup and playing with Nginx as router, which I might consider it as another post.</p>","frontmatter":{"title":"Deploy Lerna monorepo using Jenkins and Docker","date":"November 25, 2018"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/deploy-monorepo/","previous":{"fields":{"slug":"/reduce-tail-recursion/"},"frontmatter":{"title":"Reduce and Tail Recursion"}},"next":{"fields":{"slug":"/rx-toggle-buttons/"},"frontmatter":{"title":"Toggle buttons as filter using RxJS"}}}}}